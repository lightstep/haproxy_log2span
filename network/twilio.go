package network

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
)

type AutoGenerated struct {
	Items []struct {
		Name                    string `json:"name"`
		SubnetID                string `json:"subnet_id"`
		VpcID                   string `json:"vpc_id"`
		CidrBlock               string `json:"cidr_block"`
		AvailableIPAddressCount int    `json:"available_ip_address_count"`
		AvailabilityZone        string `json:"availability_zone"`
		DefaultForAz            bool   `json:"default_for_az"`
		Tags                    struct {
			Name string `json:"Name"`
		} `json:"tags"`
	} `json:"items"`
}

var jsonDoc AutoGenerated

var zonemap map[*net.IPNet]string

func init() {
	file, err := ioutil.ReadFile("/var/spool/ec2/subnets")
	if err != nil {
		fmt.Printf("Reading subnet file failed %v\n", err.Error())
		return
	}

	err = json.Unmarshal(file, &jsonDoc)

	if err != nil {
		fmt.Printf("json unmarshal failed: %v\n", err.Error())
		return
	}

	zonemap = make(map[*net.IPNet]string)

	for _, subnet := range jsonDoc.Items {
		_, IPNet, err := net.ParseCIDR(subnet.CidrBlock)
		if err != nil {
			fmt.Printf("Unable to parse %v with %v\n", subnet.CidrBlock, err.Error())
			continue
		}
		zonemap[IPNet] = subnet.AvailabilityZone
	}
}

func GetZone(ip string) string {
	sIP := net.ParseIP(ip)
	if sIP == nil {
		fmt.Printf("Failed to parse ip %v\n", ip)
		return "unknown"
	}

	for ipNet, zone := range zonemap {
		if ipNet.Contains(sIP) {
			return zone
		}
	}

	return "unknown"
}
